<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MMAE - Music/Media Audio Editor</title>
<style>
/* -- Reset & Base -------------------------------------------------------- */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f0f13;
  --surface: #1a1a24;
  --surface2: #24243a;
  --border: #333355;
  --text: #e0e0f0;
  --text-dim: #8888aa;
  --accent: #6c5ce7;
  --accent-hover: #7f70f0;
  --danger: #e74c3c;
  --danger-hover: #f55a4e;
  --success: #2ecc71;
  --radius: 8px;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  padding-bottom: 80px;
}

/* -- Layout -------------------------------------------------------------- */
.app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 24px;
}

header {
  text-align: center;
  padding: 32px 0 24px;
}

header h1 {
  font-size: 28px;
  font-weight: 700;
  letter-spacing: 2px;
}

header p {
  color: var(--text-dim);
  margin-top: 4px;
  font-size: 14px;
}

.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 16px;
}

/* -- Buttons ------------------------------------------------------------- */
button {
  cursor: pointer;
  border: none;
  border-radius: var(--radius);
  padding: 10px 20px;
  font-size: 14px;
  font-weight: 600;
  transition: background 0.15s;
}

.btn-primary {
  background: var(--accent);
  color: #fff;
}
.btn-primary:hover { background: var(--accent-hover); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

.btn-danger {
  background: var(--danger);
  color: #fff;
  padding: 4px 10px;
  font-size: 12px;
}
.btn-danger:hover { background: var(--danger-hover); }

.btn-secondary {
  background: var(--surface2);
  color: var(--text);
  border: 1px solid var(--border);
}
.btn-secondary:hover { background: var(--border); }

/* -- URL Input & Queue --------------------------------------------------- */
.url-form {
  display: flex;
  gap: 12px;
  align-items: center;
}

.url-form input[type="text"] {
  flex: 1;
  padding: 10px 16px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  font-size: 14px;
  outline: none;
}

.url-form input[type="text"]:focus {
  border-color: var(--accent);
}

.upload-separator {
  color: var(--text-dim);
  font-size: 13px;
  white-space: nowrap;
}

.upload-label {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  background: var(--surface2);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  transition: background 0.15s;
}

.upload-label:hover {
  background: var(--border);
}

.upload-label input[type="file"] {
  display: none;
}

.url-queue {
  margin-top: 12px;
}

.url-queue-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 6px;
  font-size: 13px;
  font-family: monospace;
  word-break: break-all;
}

.url-queue-item .url-text {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.url-queue-item .queue-status {
  font-size: 12px;
  color: var(--text-dim);
  white-space: nowrap;
}

.url-queue-item .queue-status.downloading {
  color: var(--accent);
}

.url-queue-item .queue-status.uploading {
  color: var(--accent);
}

.url-queue-item .queue-status.done {
  color: var(--success);
}

.url-queue-item .queue-status.error {
  color: var(--danger);
}

.url-queue-item .queue-remove {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 16px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
}

.url-queue-item .queue-remove:hover {
  color: var(--danger);
}

.queue-actions {
  margin-top: 10px;
  display: flex;
  gap: 10px;
}

/* -- Status / Error ------------------------------------------------------ */
.status {
  margin-top: 12px;
  font-size: 13px;
  color: var(--text-dim);
  min-height: 20px;
}

.status.error { color: var(--danger); }

.spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--text-dim);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
  vertical-align: middle;
  margin-right: 6px;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* -- Track Panels -------------------------------------------------------- */
#tracks-container {
  margin-top: 16px;
}

.track-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 16px;
  transition: border-color 0.15s;
}

.track-card.active {
  border-color: var(--accent);
}

.toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.toolbar .title {
  font-weight: 600;
  font-size: 15px;
  margin-right: auto;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 400px;
}

.toolbar .time-display {
  font-family: monospace;
  font-size: 13px;
  color: var(--text-dim);
  min-width: 120px;
}

/* -- Spectrogram Container ----------------------------------------------- */
.spectrogram-wrap {
  position: relative;
  overflow-x: auto;
  overflow-y: hidden;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: #000;
}

.spectrogram-wrap canvas {
  display: block;
}

/* -- Overlay layer for regions + playhead -------------------------------- */
.overlay {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  pointer-events: none;
}

.playhead {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #fff;
  pointer-events: none;
  z-index: 20;
  transition: left 0.03s linear;
}

/* -- Regions ------------------------------------------------------------- */
.region {
  position: absolute;
  top: 0;
  height: 100%;
  pointer-events: auto;
  cursor: grab;
  z-index: 10;
  border-left: 3px solid;
  border-right: 3px solid;
}

.region:active { cursor: grabbing; }

.region .handle {
  position: absolute;
  top: 0;
  width: 8px;
  height: 100%;
  cursor: ew-resize;
  z-index: 15;
}

.region .handle-left { left: -5px; }
.region .handle-right { right: -5px; }

.region .region-label {
  position: absolute;
  top: 2px;
  left: 6px;
  font-size: 11px;
  color: #fff;
  background: rgba(0,0,0,0.6);
  padding: 1px 5px;
  border-radius: 3px;
  white-space: nowrap;
  pointer-events: none;
  user-select: none;
}

.region .region-delete {
  position: absolute;
  top: 2px;
  right: 6px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: rgba(231,76,60,0.9);
  color: #fff;
  font-size: 12px;
  line-height: 18px;
  text-align: center;
  cursor: pointer;
  pointer-events: auto;
  z-index: 16;
  border: none;
  padding: 0;
}

/* -- Regions List -------------------------------------------------------- */
.regions-list {
  margin-top: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.region-tag {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 12px;
  font-size: 13px;
  font-family: monospace;
}

.region-tag .color-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
}

/* -- Timeline Bar -------------------------------------------------------- */
.timeline-bar {
  position: relative;
  height: 48px;
  margin-top: 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  overflow: hidden;
  cursor: pointer;
}

.timeline-bar canvas {
  display: block;
  width: 100%;
  height: 100%;
}

.timeline-viewport {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(108, 92, 231, 0.2);
  border-left: 2px solid var(--accent);
  border-right: 2px solid var(--accent);
  cursor: grab;
  z-index: 2;
  min-width: 4px;
}

.timeline-viewport:active {
  cursor: grabbing;
}

/* -- Drag selection ------------------------------------------------------ */
.drag-selection {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(108, 92, 231, 0.2);
  border: 2px dashed rgba(108, 92, 231, 0.7);
  pointer-events: none;
  z-index: 5;
}

/* -- Zoom info ----------------------------------------------------------- */
.zoom-info {
  font-size: 12px;
  color: var(--text-dim);
  margin-top: 6px;
}

/* -- JSON Result Panel --------------------------------------------------- */
#json-result-panel {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 200;
  background: rgba(0,0,0,0.6);
  justify-content: center;
  align-items: center;
}
#json-result-panel.visible {
  display: flex;
}
#json-result-panel .panel-inner {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  width: 700px;
  max-width: 90vw;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}
#json-result-panel .panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
}
#json-result-panel .panel-header h3 {
  font-size: 16px;
  font-weight: 600;
}
#json-result-panel .panel-header .panel-actions {
  display: flex;
  gap: 8px;
}
#json-result-panel .panel-body {
  flex: 1;
  overflow: auto;
  padding: 16px 20px;
}
#json-result-panel .panel-body pre {
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.5;
  color: var(--text);
  white-space: pre-wrap;
  word-break: break-all;
  margin: 0;
}

/* -- Global Controls Bar ------------------------------------------------- */
#global-controls {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--surface);
  border-top: 1px solid var(--border);
  padding: 14px 24px;
  display: none;
  justify-content: center;
  gap: 16px;
  z-index: 100;
}

#global-controls.visible {
  display: flex;
}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>MMAE</h1>
    <p>Music / Media Audio Editor</p>
  </header>

  <!-- URL Input & Queue -->
  <div class="card" id="download-card">
    <div class="url-form">
      <input type="text" id="url-input" placeholder="Paste YouTube URL(s)..." autocomplete="off">
      <button class="btn-secondary" id="add-btn">Add</button>
      <span class="upload-separator">or</span>
      <label class="upload-label">Upload Files
        <input type="file" id="file-input" multiple accept=".mp3,.wav,.flac,.ogg,.m4a,.aac,.wma,.opus,.webm,audio/*">
      </label>
      <button class="btn-primary" id="process-all-btn" disabled>Process All</button>
    </div>
    <div class="url-queue" id="url-queue"></div>
    <div class="status" id="download-status"></div>
  </div>

  <!-- Track Panels -->
  <div id="tracks-container"></div>
</div>

<!-- Global Controls -->
<div id="global-controls">
  <button class="btn-primary" id="clip-all-btn">Clip All Tracks</button>
  <button class="btn-secondary" id="stop-all-btn">Stop All</button>
</div>

<!-- JSON Result Panel -->
<div id="json-result-panel">
  <div class="panel-inner">
    <div class="panel-header">
      <h3>Clip Results</h3>
      <div class="panel-actions">
        <button class="btn-primary" id="download-json-btn">Download JSON</button>
        <button class="btn-secondary" id="close-json-panel-btn">Close</button>
      </div>
    </div>
    <div class="panel-body">
      <pre id="json-result-content"></pre>
    </div>
  </div>
</div>

<script>
// == Constants ================================================================
const REGION_COLORS = [
  'rgba(108,92,231,0.35)',
  'rgba(0,184,148,0.35)',
  'rgba(253,121,168,0.35)',
  'rgba(255,177,66,0.35)',
  'rgba(116,185,255,0.35)',
  'rgba(232,67,147,0.35)',
  'rgba(85,239,196,0.35)',
  'rgba(255,118,117,0.35)',
];

const REGION_BORDER_COLORS = [
  '#6c5ce7', '#00b894', '#fd79a8', '#ffb142',
  '#74b9ff', '#e84393', '#55efc4', '#ff7675',
];

// == Viridis Colormap LUT =====================================================
function viridis(t) {
  t = Math.max(0, Math.min(1, t));
  const r = Math.round(255 * Math.max(0, Math.min(1, -0.35 + 2.5 * t - 1.7 * t * t)));
  const g = Math.round(255 * Math.max(0, Math.min(1, -0.05 + 1.5 * t - 0.7 * t * t)));
  const b = Math.round(255 * Math.max(0, Math.min(1, 0.5 + 0.8 * t - 1.8 * t * t + 0.9 * t * t * t)));
  return [r, g, b];
}

const colormapLUT = new Uint8Array(256 * 3);
for (let i = 0; i < 256; i++) {
  const [r, g, b] = viridis(i / 255);
  colormapLUT[i * 3] = r;
  colormapLUT[i * 3 + 1] = g;
  colormapLUT[i * 3 + 2] = b;
}

function formatTime(sec) {
  const m = Math.floor(sec / 60);
  const s = (sec % 60).toFixed(1);
  return `${m}:${s.padStart(4, '0')}`;
}

// == Shared State =============================================================
const sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
const tracks = [];
let activeTrackId = null;
let nextTrackId = 1;

// == URL/File Queue ===========================================================
const urlQueue = [];  // { id, type: 'url'|'file', url?, file?, name, status: 'pending'|'downloading'|'uploading'|'loading'|'done'|'error', error? }
let nextQueueId = 1;
let isProcessing = false;

const urlInput = document.getElementById('url-input');
const addBtn = document.getElementById('add-btn');
const fileInput = document.getElementById('file-input');
const processAllBtn = document.getElementById('process-all-btn');
const urlQueueEl = document.getElementById('url-queue');
const downloadStatus = document.getElementById('download-status');
const tracksContainer = document.getElementById('tracks-container');
const globalControls = document.getElementById('global-controls');
const clipAllBtn = document.getElementById('clip-all-btn');
const stopAllBtn = document.getElementById('stop-all-btn');
const jsonResultPanel = document.getElementById('json-result-panel');
const jsonResultContent = document.getElementById('json-result-content');
const downloadJsonBtn = document.getElementById('download-json-btn');
const closeJsonPanelBtn = document.getElementById('close-json-panel-btn');
let lastClipResult = null;

addBtn.addEventListener('click', addUrls);
urlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addUrls(); });
fileInput.addEventListener('change', addFiles);
processAllBtn.addEventListener('click', processAll);

function addUrls() {
  const raw = urlInput.value.trim();
  if (!raw) return;
  const urls = raw.split(/\n+/).map(u => u.trim()).filter(Boolean);
  for (const url of urls) {
    urlQueue.push({ id: nextQueueId++, type: 'url', url, name: url, status: 'pending' });
  }
  urlInput.value = '';
  renderQueue();
}

function addFiles() {
  const files = fileInput.files;
  if (!files || files.length === 0) return;
  for (const file of files) {
    urlQueue.push({ id: nextQueueId++, type: 'file', file, name: file.name, status: 'pending' });
  }
  fileInput.value = '';
  renderQueue();
}

function removeQueueItem(id) {
  const idx = urlQueue.findIndex(q => q.id === id);
  if (idx !== -1 && urlQueue[idx].status === 'pending') {
    urlQueue.splice(idx, 1);
    renderQueue();
  }
}

function renderQueue() {
  urlQueueEl.innerHTML = '';
  for (const item of urlQueue) {
    const div = document.createElement('div');
    div.className = 'url-queue-item';

    const urlSpan = document.createElement('span');
    urlSpan.className = 'url-text';
    urlSpan.textContent = item.name;
    div.appendChild(urlSpan);

    const statusSpan = document.createElement('span');
    statusSpan.className = 'queue-status';
    if (item.status === 'pending') {
      statusSpan.textContent = 'pending';
    } else if (item.status === 'downloading') {
      statusSpan.className += ' downloading';
      statusSpan.innerHTML = '<span class="spinner"></span>downloading';
    } else if (item.status === 'uploading') {
      statusSpan.className += ' uploading';
      statusSpan.innerHTML = '<span class="spinner"></span>uploading';
    } else if (item.status === 'loading') {
      statusSpan.className += ' downloading';
      statusSpan.innerHTML = '<span class="spinner"></span>loading';
    } else if (item.status === 'done') {
      statusSpan.className += ' done';
      statusSpan.textContent = 'done';
    } else if (item.status === 'error') {
      statusSpan.className += ' error';
      statusSpan.textContent = item.error || 'error';
    }
    div.appendChild(statusSpan);

    if (item.status === 'pending') {
      const removeBtn = document.createElement('span');
      removeBtn.className = 'queue-remove';
      removeBtn.textContent = '\u00d7';
      removeBtn.addEventListener('click', () => removeQueueItem(item.id));
      div.appendChild(removeBtn);
    }

    urlQueueEl.appendChild(div);
  }

  processAllBtn.disabled = urlQueue.filter(q => q.status === 'pending').length === 0 || isProcessing;
}

async function processAll() {
  if (isProcessing) return;
  isProcessing = true;
  processAllBtn.disabled = true;
  downloadStatus.textContent = '';

  const pending = urlQueue.filter(q => q.status === 'pending');
  const pendingFiles = pending.filter(q => q.type === 'file');
  const pendingUrls = pending.filter(q => q.type === 'url');

  // Batch-upload all file items at once
  if (pendingFiles.length > 0) {
    for (const item of pendingFiles) {
      item.status = 'uploading';
    }
    renderQueue();

    try {
      const formData = new FormData();
      for (const item of pendingFiles) {
        formData.append('files', item.file);
      }

      const resp = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!resp.ok) {
        const err = await resp.json();
        throw new Error(err.detail || 'Upload failed');
      }

      const results = await resp.json();

      // Create tracks for each uploaded file
      for (let i = 0; i < results.length; i++) {
        const data = results[i];
        const item = pendingFiles[i];

        item.status = 'loading';
        renderQueue();

        try {
          const track = createTrackState(data.file_id, data.filename, data.duration);
          tracks.push(track);
          createTrackPanel(track);
          await loadAudio(track);
          computeWaveformPeaks(track);
          drawTimeline(track);
          updateGlobalControls();

          item.status = 'done';
          renderQueue();
        } catch (e) {
          item.status = 'error';
          item.error = e.message;
          renderQueue();
        }
      }
    } catch (e) {
      // Mark all pending files as error
      for (const item of pendingFiles) {
        if (item.status !== 'done') {
          item.status = 'error';
          item.error = e.message;
        }
      }
      renderQueue();
    }
  }

  // Process URL items sequentially
  for (const item of pendingUrls) {
    item.status = 'downloading';
    renderQueue();

    try {
      const resp = await fetch('/api/download', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: item.url }),
      });
      if (!resp.ok) {
        const err = await resp.json();
        throw new Error(err.detail || 'Download failed');
      }
      const data = await resp.json();

      item.status = 'loading';
      renderQueue();

      const track = createTrackState(data.file_id, data.filename, data.duration);
      tracks.push(track);
      createTrackPanel(track);
      await loadAudio(track);
      computeWaveformPeaks(track);
      drawTimeline(track);
      updateGlobalControls();

      item.status = 'done';
      renderQueue();
    } catch (e) {
      item.status = 'error';
      item.error = e.message;
      renderQueue();
    }
  }

  isProcessing = false;
  processAllBtn.disabled = urlQueue.filter(q => q.status === 'pending').length === 0;
  downloadStatus.textContent = 'All items processed.';
}

// == Track State Factory ======================================================
function createTrackState(fileId, filename, duration) {
  return {
    id: nextTrackId++,
    fileId,
    filename,
    duration,
    audioBuffer: null,
    sourceNode: null,
    isPlaying: false,
    playStartTime: 0,
    playOffset: 0,
    pxPerSec: 100,
    minPxPerSec: 20,
    maxPxPerSec: 1000,
    regions: [],
    nextRegionId: 1,
    spectrogramData: null,
    numFrames: 0,
    numBins: 0,
    fftSize: 2048,
    hopSize: 512,
    animFrame: null,
    monoData: null,
    waveformPeaks: null,
    magMin: 0,
    magMax: 0,
    dom: {},  // filled by createTrackPanel
  };
}

// == Load & Decode Audio ======================================================
async function loadAudio(track) {
  if (sharedAudioCtx.state === 'suspended') sharedAudioCtx.resume();
  const resp = await fetch(`/api/audio/${track.fileId}`);
  const arrayBuf = await resp.arrayBuffer();
  track.audioBuffer = await sharedAudioCtx.decodeAudioData(arrayBuf);
  track.duration = track.audioBuffer.duration;
  computeSpectrogram(track);
}

// == Spectrogram Computation ==================================================
function computeSpectrogram(track) {
  const buf = track.audioBuffer;
  const numChannels = buf.numberOfChannels;
  const length = buf.length;
  const mono = new Float32Array(length);
  for (let ch = 0; ch < numChannels; ch++) {
    const chData = buf.getChannelData(ch);
    for (let i = 0; i < length; i++) {
      mono[i] += chData[i] / numChannels;
    }
  }

  const fftSize = track.fftSize;
  const hopSize = track.hopSize;
  const numFrames = Math.floor((length - fftSize) / hopSize) + 1;
  const numBins = fftSize / 2;

  const win = new Float32Array(fftSize);
  for (let i = 0; i < fftSize; i++) {
    win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
  }

  const logN = Math.log2(fftSize);
  const bitRev = new Uint32Array(fftSize);
  for (let i = 0; i < fftSize; i++) {
    let rev = 0, val = i;
    for (let j = 0; j < logN; j++) {
      rev = (rev << 1) | (val & 1);
      val >>= 1;
    }
    bitRev[i] = rev;
  }

  const twiddleRe = new Float64Array(fftSize / 2);
  const twiddleIm = new Float64Array(fftSize / 2);
  for (let i = 0; i < fftSize / 2; i++) {
    const angle = -2 * Math.PI * i / fftSize;
    twiddleRe[i] = Math.cos(angle);
    twiddleIm[i] = Math.sin(angle);
  }

  const magnitudes = new Float32Array(numFrames * numBins);
  const re = new Float64Array(fftSize);
  const im = new Float64Array(fftSize);

  for (let frame = 0; frame < numFrames; frame++) {
    const offset = frame * hopSize;
    for (let i = 0; i < fftSize; i++) {
      re[bitRev[i]] = mono[offset + i] * win[i];
    }
    im.fill(0);

    for (let size = 2; size <= fftSize; size *= 2) {
      const halfSize = size / 2;
      const step = fftSize / size;
      for (let i = 0; i < fftSize; i += size) {
        for (let j = 0; j < halfSize; j++) {
          const twIdx = j * step;
          const tRe = re[i + j + halfSize] * twiddleRe[twIdx] - im[i + j + halfSize] * twiddleIm[twIdx];
          const tIm = re[i + j + halfSize] * twiddleIm[twIdx] + im[i + j + halfSize] * twiddleRe[twIdx];
          re[i + j + halfSize] = re[i + j] - tRe;
          im[i + j + halfSize] = im[i + j] - tIm;
          re[i + j] += tRe;
          im[i + j] += tIm;
        }
      }
    }

    const baseIdx = frame * numBins;
    for (let i = 0; i < numBins; i++) {
      const mag = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
      magnitudes[baseIdx + i] = 20 * Math.log10(mag + 1e-10);
    }
  }

  track.spectrogramData = magnitudes;
  track.numFrames = numFrames;
  track.numBins = numBins;
  track.monoData = mono;

  let minVal = Infinity, maxVal = -Infinity;
  for (let i = 0; i < magnitudes.length; i++) {
    if (magnitudes[i] < minVal) minVal = magnitudes[i];
    if (magnitudes[i] > maxVal) maxVal = magnitudes[i];
  }
  track.magMin = minVal;
  track.magMax = maxVal;

  drawSpectrogram(track);
}

// == Draw Spectrogram =========================================================
function drawSpectrogram(track) {
  if (!track.spectrogramData) return;
  const { numFrames, numBins, spectrogramData: magnitudes, magMin: minVal, magMax, hopSize, audioBuffer } = track;
  const d = track.dom;
  const range = magMax - minVal || 1;
  const timePerFrame = hopSize / audioBuffer.sampleRate;
  const totalWidth = Math.ceil(numFrames * track.pxPerSec * timePerFrame);
  const height = 300;

  d.canvas.width = totalWidth;
  d.canvas.height = height;
  d.overlay.style.width = totalWidth + 'px';
  d.overlay.style.height = height + 'px';

  const ctx = d.canvas.getContext('2d');
  const imageData = ctx.createImageData(totalWidth, height);
  const data = imageData.data;

  for (let px = 0; px < totalWidth; px++) {
    const frame = Math.min(numFrames - 1, Math.round(px / (track.pxPerSec * timePerFrame)));
    const frameBase = frame * numBins;
    for (let py = 0; py < height; py++) {
      const bin = Math.min(numBins - 1, Math.round((1 - py / height) * numBins));
      const val = (magnitudes[frameBase + bin] - minVal) / range;
      const lutIdx = Math.round(val * 255) * 3;
      const idx = (py * totalWidth + px) * 4;
      data[idx] = colormapLUT[lutIdx];
      data[idx + 1] = colormapLUT[lutIdx + 1];
      data[idx + 2] = colormapLUT[lutIdx + 2];
      data[idx + 3] = 255;
    }
  }

  ctx.putImageData(imageData, 0, 0);
  updateRegionPositions(track);
  updateTimelineViewport(track);
}

// == Waveform Peaks ===========================================================
function computeWaveformPeaks(track) {
  const mono = track.monoData;
  if (!mono) return;
  const width = track.dom.timelineBar.clientWidth || 1150;
  const samplesPerPx = mono.length / width;
  const peaks = new Float32Array(width);
  for (let i = 0; i < width; i++) {
    const start = Math.floor(i * samplesPerPx);
    const end = Math.min(mono.length, Math.floor((i + 1) * samplesPerPx));
    let max = 0;
    for (let j = start; j < end; j++) {
      const v = Math.abs(mono[j]);
      if (v > max) max = v;
    }
    peaks[i] = max;
  }
  track.waveformPeaks = peaks;
}

// == Timeline Drawing =========================================================
function drawTimeline(track) {
  if (!track.waveformPeaks) return;
  const d = track.dom;
  const barWidth = d.timelineBar.clientWidth;
  const barHeight = d.timelineBar.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  const tCtx = d.timelineCanvas.getContext('2d');

  d.timelineCanvas.width = barWidth * dpr;
  d.timelineCanvas.height = barHeight * dpr;
  tCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const cs = getComputedStyle(document.documentElement);
  const bgColor = cs.getPropertyValue('--surface').trim() || '#1a1a24';
  const textDim = cs.getPropertyValue('--text-dim').trim() || '#8888aa';
  const borderColor = cs.getPropertyValue('--border').trim() || '#333355';
  const accent = cs.getPropertyValue('--accent').trim() || '#6c5ce7';

  tCtx.fillStyle = bgColor;
  tCtx.fillRect(0, 0, barWidth, barHeight);

  const peaks = track.waveformPeaks;
  const halfH = (barHeight - 14) / 2;
  const centerY = halfH;
  tCtx.strokeStyle = accent;
  tCtx.globalAlpha = 0.5;
  tCtx.lineWidth = 1;
  tCtx.beginPath();
  for (let i = 0; i < peaks.length && i < barWidth; i++) {
    const h = peaks[i] * halfH;
    tCtx.moveTo(i + 0.5, centerY - h);
    tCtx.lineTo(i + 0.5, centerY + h);
  }
  tCtx.stroke();
  tCtx.globalAlpha = 1.0;

  const duration = track.duration;
  if (duration <= 0) return;

  const tickAreaTop = barHeight - 14;
  const niceIntervals = [0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600];
  const minPxBetweenLabels = 60;
  const pxPerSec = barWidth / duration;
  let majorInterval = niceIntervals[niceIntervals.length - 1];
  for (const iv of niceIntervals) {
    if (iv * pxPerSec >= minPxBetweenLabels) {
      majorInterval = iv;
      break;
    }
  }

  let minorCount = 4;
  if (majorInterval === 0.5 || majorInterval === 5 || majorInterval === 50) minorCount = 5;
  const minorInterval = majorInterval / minorCount;

  tCtx.strokeStyle = borderColor;
  tCtx.lineWidth = 1;
  tCtx.beginPath();
  for (let t = 0; t <= duration + minorInterval / 2; t += minorInterval) {
    const x = Math.round((t / duration) * barWidth) + 0.5;
    if (x > barWidth) break;
    tCtx.moveTo(x, tickAreaTop);
    tCtx.lineTo(x, tickAreaTop + 4);
  }
  tCtx.stroke();

  tCtx.strokeStyle = textDim;
  tCtx.fillStyle = textDim;
  tCtx.font = '9px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace';
  tCtx.textAlign = 'center';
  tCtx.textBaseline = 'top';
  tCtx.beginPath();
  for (let t = 0; t <= duration + majorInterval / 2; t += majorInterval) {
    const x = Math.round((t / duration) * barWidth) + 0.5;
    if (x > barWidth) break;
    tCtx.moveTo(x, tickAreaTop);
    tCtx.lineTo(x, tickAreaTop + 7);
    const mm = Math.floor(t / 60);
    const ss = t % 60;
    const label = majorInterval < 1
      ? `${mm}:${ss.toFixed(1).padStart(4, '0')}`
      : `${mm}:${Math.floor(ss).toString().padStart(2, '0')}`;
    tCtx.fillText(label, x, tickAreaTop + 5);
  }
  tCtx.stroke();

  updateTimelineViewport(track);
}

// == Timeline Viewport ========================================================
function updateTimelineViewport(track) {
  if (!track.spectrogramData) return;
  const d = track.dom;
  const barWidth = d.timelineBar.clientWidth;
  const totalCanvasWidth = d.canvas.width;
  if (totalCanvasWidth <= 0) return;

  const scrollLeft = d.spectrogramWrap.scrollLeft;
  const visibleWidth = d.spectrogramWrap.clientWidth;
  const leftFrac = scrollLeft / totalCanvasWidth;
  const visFrac = visibleWidth / totalCanvasWidth;

  d.timelineViewport.style.left = (leftFrac * barWidth) + 'px';
  d.timelineViewport.style.width = Math.max(4, visFrac * barWidth) + 'px';
}

// == Playback =================================================================
function togglePlay(track) {
  if (track.isPlaying) {
    stopPlayback(track);
  } else {
    startPlayback(track, track.playOffset);
  }
}

function startPlayback(track, offset) {
  if (!track.audioBuffer) return;
  if (sharedAudioCtx.state === 'suspended') sharedAudioCtx.resume();

  if (track.sourceNode) {
    track.sourceNode.onended = null;
    track.sourceNode.stop();
  }

  const source = sharedAudioCtx.createBufferSource();
  source.buffer = track.audioBuffer;
  source.connect(sharedAudioCtx.destination);
  source.onended = () => {
    if (track.isPlaying) {
      track.isPlaying = false;
      track.playOffset = 0;
      track.dom.playBtn.textContent = 'Play';
      updatePlayhead(track);
    }
  };

  track.sourceNode = source;
  track.playStartTime = sharedAudioCtx.currentTime;
  track.playOffset = offset;
  track.isPlaying = true;
  track.dom.playBtn.textContent = 'Pause';
  source.start(0, offset);
  animatePlayhead(track);
}

function stopPlayback(track) {
  if (track.sourceNode) {
    track.sourceNode.onended = null;
    track.sourceNode.stop();
  }
  track.playOffset = track.playOffset + (sharedAudioCtx.currentTime - track.playStartTime);
  if (track.playOffset >= track.duration) track.playOffset = 0;
  track.isPlaying = false;
  track.dom.playBtn.textContent = 'Play';
  if (track.animFrame) cancelAnimationFrame(track.animFrame);
  updatePlayhead(track);
}

function animatePlayhead(track) {
  if (!track.isPlaying) return;
  updatePlayhead(track);
  updateTimeDisplay(track);
  drawTimeline(track);
  drawTimelinePlayhead(track);
  track.animFrame = requestAnimationFrame(() => animatePlayhead(track));
}

function updatePlayhead(track) {
  const cur = track.isPlaying
    ? track.playOffset + (sharedAudioCtx.currentTime - track.playStartTime)
    : track.playOffset;
  const pxPos = (cur / track.duration) * track.dom.canvas.width;
  track.dom.playhead.style.left = pxPos + 'px';
  updateTimeDisplay(track);
}

function updateTimeDisplay(track) {
  const cur = track.isPlaying
    ? track.playOffset + (sharedAudioCtx.currentTime - track.playStartTime)
    : track.playOffset;
  track.dom.timeDisplay.textContent = `${formatTime(Math.min(cur, track.duration))} / ${formatTime(track.duration)}`;
}

// == Timeline Playhead ========================================================
function drawTimelinePlayhead(track) {
  if (!track.waveformPeaks || !track.isPlaying) return;
  const cur = track.playOffset + (sharedAudioCtx.currentTime - track.playStartTime);
  const frac = Math.min(cur, track.duration) / track.duration;
  const d = track.dom;
  const barWidth = d.timelineBar.clientWidth;
  const barHeight = d.timelineBar.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  const x = frac * barWidth;
  const tCtx = d.timelineCanvas.getContext('2d');

  tCtx.save();
  tCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  tCtx.strokeStyle = '#fff';
  tCtx.lineWidth = 1.5;
  tCtx.beginPath();
  tCtx.moveTo(x, 0);
  tCtx.lineTo(x, barHeight);
  tCtx.stroke();
  tCtx.restore();
}

// == Region Helpers ===========================================================
function createRegionElement(track, region) {
  const d = track.dom;
  const el = document.createElement('div');
  el.className = 'region';
  el.dataset.regionId = region.id;
  el.style.background = region.color;
  el.style.borderColor = region.borderColor;

  const label = document.createElement('div');
  label.className = 'region-label';
  el.appendChild(label);

  const delBtn = document.createElement('div');
  delBtn.className = 'region-delete';
  delBtn.textContent = '\u00d7';
  delBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    removeRegion(track, region.id);
  });
  el.appendChild(delBtn);

  const handleLeft = document.createElement('div');
  handleLeft.className = 'handle handle-left';
  el.appendChild(handleLeft);

  const handleRight = document.createElement('div');
  handleRight.className = 'handle handle-right';
  el.appendChild(handleRight);

  d.overlay.appendChild(el);

  let dragType = null;
  let dragStartX = 0;
  let dragStartStart = 0;
  let dragStartEnd = 0;

  function onPointerDown(e) {
    e.stopPropagation();
    e.preventDefault();
    const target = e.target;
    if (target === handleLeft) dragType = 'left';
    else if (target === handleRight) dragType = 'right';
    else if (target === delBtn) return;
    else dragType = 'move';

    dragStartX = e.clientX + d.spectrogramWrap.scrollLeft;
    dragStartStart = region.start;
    dragStartEnd = region.end;
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
  }

  function onPointerMove(e) {
    const dx = (e.clientX + d.spectrogramWrap.scrollLeft) - dragStartX;
    const dt = (dx / d.canvas.width) * track.duration;

    if (dragType === 'move') {
      let newStart = dragStartStart + dt;
      let newEnd = dragStartEnd + dt;
      const len = newEnd - newStart;
      if (newStart < 0) { newStart = 0; newEnd = len; }
      if (newEnd > track.duration) { newEnd = track.duration; newStart = newEnd - len; }
      region.start = newStart;
      region.end = newEnd;
    } else if (dragType === 'left') {
      region.start = Math.max(0, Math.min(region.end - 0.05, dragStartStart + dt));
    } else if (dragType === 'right') {
      region.end = Math.min(track.duration, Math.max(region.start + 0.05, dragStartEnd + dt));
    }

    positionRegionElement(track, el, region);
    updateRegionsList(track);
  }

  function onPointerUp() {
    dragType = null;
    document.removeEventListener('pointermove', onPointerMove);
    document.removeEventListener('pointerup', onPointerUp);
  }

  el.addEventListener('pointerdown', onPointerDown);
  positionRegionElement(track, el, region);
}

function positionRegionElement(track, el, region) {
  const leftPx = (region.start / track.duration) * track.dom.canvas.width;
  const rightPx = (region.end / track.duration) * track.dom.canvas.width;
  el.style.left = leftPx + 'px';
  el.style.width = (rightPx - leftPx) + 'px';

  const label = el.querySelector('.region-label');
  if (label) {
    label.textContent = `${formatTime(region.start)} - ${formatTime(region.end)}`;
  }
}

function updateRegionPositions(track) {
  const regionEls = track.dom.overlay.querySelectorAll('.region');
  regionEls.forEach(el => {
    const id = parseInt(el.dataset.regionId);
    const region = track.regions.find(r => r.id === id);
    if (region) positionRegionElement(track, el, region);
  });
}

function removeRegion(track, id) {
  track.regions = track.regions.filter(r => r.id !== id);
  const el = track.dom.overlay.querySelector(`.region[data-region-id="${id}"]`);
  if (el) el.remove();
  updateRegionsList(track);
}

function updateRegionsList(track) {
  const d = track.dom;
  d.regionsList.innerHTML = '';
  track.regions.forEach(r => {
    const tag = document.createElement('div');
    tag.className = 'region-tag';
    const dot = document.createElement('span');
    dot.className = 'color-dot';
    dot.style.background = r.borderColor;
    tag.appendChild(dot);
    tag.appendChild(document.createTextNode(` ${formatTime(r.start)} - ${formatTime(r.end)} `));
    const delBtn = document.createElement('button');
    delBtn.className = 'btn-danger';
    delBtn.textContent = '\u00d7';
    delBtn.addEventListener('click', () => removeRegion(track, r.id));
    tag.appendChild(delBtn);
    d.regionsList.appendChild(tag);
  });
}

// == Dynamic Track Panel ======================================================
function createTrackPanel(track) {
  const card = document.createElement('div');
  card.className = 'track-card';
  card.dataset.trackId = track.id;

  card.innerHTML = `
    <div class="toolbar">
      <span class="title"></span>
      <span class="time-display">0:00.0 / 0:00.0</span>
      <button class="btn-secondary play-btn">Play</button>
      <button class="btn-secondary add-region-btn">+ Region</button>
      <button class="btn-danger remove-track-btn">Remove</button>
    </div>
    <div class="spectrogram-wrap">
      <canvas></canvas>
      <div class="overlay">
        <div class="playhead" style="left:0"></div>
      </div>
    </div>
    <div class="timeline-bar">
      <canvas></canvas>
      <div class="timeline-viewport"></div>
    </div>
    <div class="zoom-info">Scroll to zoom. Click to seek. Drag to select a region.</div>
    <div class="regions-list"></div>
  `;

  tracksContainer.appendChild(card);

  // Store DOM references
  const d = track.dom;
  d.card = card;
  d.titleEl = card.querySelector('.title');
  d.timeDisplay = card.querySelector('.time-display');
  d.playBtn = card.querySelector('.play-btn');
  d.addRegionBtn = card.querySelector('.add-region-btn');
  d.removeBtn = card.querySelector('.remove-track-btn');
  d.spectrogramWrap = card.querySelector('.spectrogram-wrap');
  d.canvas = d.spectrogramWrap.querySelector('canvas');
  d.overlay = card.querySelector('.overlay');
  d.playhead = card.querySelector('.playhead');
  d.timelineBar = card.querySelector('.timeline-bar');
  d.timelineCanvas = d.timelineBar.querySelector('canvas');
  d.timelineViewport = card.querySelector('.timeline-viewport');
  d.regionsList = card.querySelector('.regions-list');

  d.titleEl.textContent = track.filename;

  initTrack(track);

  // Set as active
  setActiveTrack(track.id);
}

// == Init Track (attach handlers) =============================================
function initTrack(track) {
  const d = track.dom;

  // Play/pause
  d.playBtn.addEventListener('click', () => togglePlay(track));

  // Add region
  d.addRegionBtn.addEventListener('click', () => {
    const scrollFrac = d.spectrogramWrap.scrollLeft / (d.canvas.width || 1);
    const visFrac = d.spectrogramWrap.clientWidth / (d.canvas.width || 1);
    const centerTime = (scrollFrac + visFrac / 2) * track.duration;
    const regionLen = Math.min(5, track.duration * 0.1);
    const start = Math.max(0, centerTime - regionLen / 2);
    const end = Math.min(track.duration, start + regionLen);

    const colorIdx = track.regions.length % REGION_COLORS.length;
    const region = {
      id: track.nextRegionId++,
      start,
      end,
      color: REGION_COLORS[colorIdx],
      borderColor: REGION_BORDER_COLORS[colorIdx],
    };
    track.regions.push(region);
    createRegionElement(track, region);
    updateRegionsList(track);
  });

  // Remove track
  d.removeBtn.addEventListener('click', () => removeTrack(track.id));

  // Scroll sync
  d.spectrogramWrap.addEventListener('scroll', () => updateTimelineViewport(track));

  // Zoom
  d.spectrogramWrap.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = d.spectrogramWrap.getBoundingClientRect();
    const mouseX = e.clientX - rect.left + d.spectrogramWrap.scrollLeft;
    const timeAtMouse = (mouseX / d.canvas.width) * track.duration;

    const factor = e.deltaY < 0 ? 1.2 : 1 / 1.2;
    track.pxPerSec = Math.max(track.minPxPerSec, Math.min(track.maxPxPerSec, track.pxPerSec * factor));

    drawSpectrogram(track);

    const newMouseX = (timeAtMouse / track.duration) * d.canvas.width;
    d.spectrogramWrap.scrollLeft = newMouseX - (e.clientX - rect.left);
  }, { passive: false });

  // Click-to-seek / drag-to-select
  initDragSelect(track);

  // Timeline interactions
  initTimelineInteractions(track);

  // Set active on pointerdown
  d.card.addEventListener('pointerdown', () => setActiveTrack(track.id));
}

// == Drag to Select / Seek ====================================================
function initDragSelect(track) {
  const d = track.dom;
  let isDragging = false;
  let dragStartX = 0;
  let dragStartClientX = 0;
  let selectionDiv = null;
  const DRAG_THRESHOLD = 5;

  d.spectrogramWrap.addEventListener('pointerdown', (e) => {
    if (e.target.closest('.region') || e.target.closest('.region-delete')) return;
    if (e.button !== 0) return;

    const wrapRect = d.spectrogramWrap.getBoundingClientRect();
    dragStartX = e.clientX - wrapRect.left + d.spectrogramWrap.scrollLeft;
    dragStartClientX = e.clientX;
    isDragging = false;

    selectionDiv = document.createElement('div');
    selectionDiv.className = 'drag-selection';
    selectionDiv.style.left = dragStartX + 'px';
    selectionDiv.style.width = '0px';
    selectionDiv.style.display = 'none';
    d.overlay.appendChild(selectionDiv);

    document.addEventListener('pointermove', onDragMove);
    document.addEventListener('pointerup', onDragUp);
  });

  function onDragMove(e) {
    const dx = e.clientX - dragStartClientX;
    if (!isDragging && Math.abs(dx) < DRAG_THRESHOLD) return;
    isDragging = true;
    selectionDiv.style.display = 'block';

    const wrapRect = d.spectrogramWrap.getBoundingClientRect();
    const currentX = e.clientX - wrapRect.left + d.spectrogramWrap.scrollLeft;
    const left = Math.max(0, Math.min(dragStartX, currentX));
    const right = Math.min(d.canvas.width, Math.max(dragStartX, currentX));
    selectionDiv.style.left = left + 'px';
    selectionDiv.style.width = (right - left) + 'px';

    const edgeZone = 40;
    if (e.clientX < wrapRect.left + edgeZone) {
      d.spectrogramWrap.scrollLeft -= 8;
    } else if (e.clientX > wrapRect.right - edgeZone) {
      d.spectrogramWrap.scrollLeft += 8;
    }
  }

  function onDragUp(e) {
    document.removeEventListener('pointermove', onDragMove);
    document.removeEventListener('pointerup', onDragUp);

    if (selectionDiv) {
      selectionDiv.remove();
      selectionDiv = null;
    }

    if (isDragging) {
      const wrapRect = d.spectrogramWrap.getBoundingClientRect();
      const endX = e.clientX - wrapRect.left + d.spectrogramWrap.scrollLeft;
      const x1 = Math.max(0, Math.min(dragStartX, endX));
      const x2 = Math.min(d.canvas.width, Math.max(dragStartX, endX));
      const t1 = (x1 / d.canvas.width) * track.duration;
      const t2 = (x2 / d.canvas.width) * track.duration;

      if (t2 - t1 >= 0.05) {
        const colorIdx = track.regions.length % REGION_COLORS.length;
        const region = {
          id: track.nextRegionId++,
          start: t1,
          end: t2,
          color: REGION_COLORS[colorIdx],
          borderColor: REGION_BORDER_COLORS[colorIdx],
        };
        track.regions.push(region);
        createRegionElement(track, region);
        updateRegionsList(track);
      }
    } else {
      const wrapRect = d.spectrogramWrap.getBoundingClientRect();
      const x = e.clientX - wrapRect.left + d.spectrogramWrap.scrollLeft;
      const time = (x / d.canvas.width) * track.duration;

      if (track.isPlaying) {
        stopPlayback(track);
        startPlayback(track, Math.max(0, Math.min(time, track.duration)));
      } else {
        track.playOffset = Math.max(0, Math.min(time, track.duration));
        updatePlayhead(track);
      }
    }

    isDragging = false;
  }
}

// == Timeline Interactions ====================================================
function initTimelineInteractions(track) {
  const d = track.dom;

  d.timelineBar.addEventListener('pointerdown', (e) => {
    if (!track.spectrogramData) return;
    const barRect = d.timelineBar.getBoundingClientRect();

    if (e.target === d.timelineViewport) {
      e.preventDefault();
      const startX = e.clientX;
      const startScroll = d.spectrogramWrap.scrollLeft;
      const barWidth = d.timelineBar.clientWidth;
      const totalCanvasWidth = d.canvas.width;

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const scrollDelta = (dx / barWidth) * totalCanvasWidth;
        d.spectrogramWrap.scrollLeft = startScroll + scrollDelta;
      }

      function onUp() {
        document.removeEventListener('pointermove', onMove);
        document.removeEventListener('pointerup', onUp);
      }

      document.addEventListener('pointermove', onMove);
      document.addEventListener('pointerup', onUp);
    } else {
      const x = e.clientX - barRect.left;
      const barWidth = d.timelineBar.clientWidth;
      const frac = x / barWidth;
      const targetScrollCenter = frac * d.canvas.width;
      d.spectrogramWrap.scrollLeft = targetScrollCenter - d.spectrogramWrap.clientWidth / 2;
    }
  });
}

// == Active Track =============================================================
function setActiveTrack(id) {
  activeTrackId = id;
  document.querySelectorAll('.track-card').forEach(card => {
    card.classList.toggle('active', parseInt(card.dataset.trackId) === id);
  });
}

function getActiveTrack() {
  return tracks.find(t => t.id === activeTrackId) || null;
}

// == Remove Track =============================================================
function removeTrack(id) {
  const idx = tracks.findIndex(t => t.id === id);
  if (idx === -1) return;
  const track = tracks[idx];

  if (track.isPlaying) stopPlayback(track);
  if (track.animFrame) cancelAnimationFrame(track.animFrame);
  track.dom.card.remove();
  tracks.splice(idx, 1);

  if (activeTrackId === id) {
    activeTrackId = tracks.length > 0 ? tracks[0].id : null;
    if (activeTrackId) setActiveTrack(activeTrackId);
  }

  updateGlobalControls();
}

// == Global Controls ==========================================================
function updateGlobalControls() {
  globalControls.classList.toggle('visible', tracks.length > 0);
}

clipAllBtn.addEventListener('click', async () => {
  const tracksWithRegions = tracks.filter(t => t.regions.length > 0);
  if (tracksWithRegions.length === 0) {
    alert('Add at least one region to a track first.');
    return;
  }

  clipAllBtn.disabled = true;
  clipAllBtn.textContent = 'Clipping...';

  try {
    const resp = await fetch('/api/clip-multi', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tracks: tracksWithRegions.map(t => ({
          file_id: t.fileId,
          track_name: t.filename,
          regions: t.regions.map(r => ({ start: r.start, end: r.end })),
        })),
      }),
    });

    if (!resp.ok) {
      const err = await resp.json();
      throw new Error(err.detail || 'Clip failed');
    }

    const data = await resp.json();
    lastClipResult = data;
    jsonResultContent.textContent = JSON.stringify(data, null, 2);
    jsonResultPanel.classList.add('visible');
  } catch (e) {
    alert('Error: ' + e.message);
  } finally {
    clipAllBtn.disabled = false;
    clipAllBtn.textContent = 'Clip All Tracks';
  }
});

stopAllBtn.addEventListener('click', () => {
  for (const track of tracks) {
    if (track.isPlaying) stopPlayback(track);
  }
});

// == JSON Result Panel ========================================================
closeJsonPanelBtn.addEventListener('click', () => {
  jsonResultPanel.classList.remove('visible');
});
jsonResultPanel.addEventListener('click', (e) => {
  if (e.target === jsonResultPanel) jsonResultPanel.classList.remove('visible');
});
downloadJsonBtn.addEventListener('click', () => {
  if (!lastClipResult) return;
  const blob = new Blob([JSON.stringify(lastClipResult, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'clip-results.json';
  a.click();
  URL.revokeObjectURL(url);
});

// == Keyboard Shortcuts =======================================================
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  const track = getActiveTrack();
  if (!track || !track.audioBuffer) return;

  if (e.key === ' ') {
    e.preventDefault();
    togglePlay(track);
    return;
  }

  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
    e.preventDefault();
    const delta = e.shiftKey ? 1.0 : 0.1;
    const direction = e.key === 'ArrowLeft' ? -1 : 1;

    let cur;
    if (track.isPlaying) {
      cur = track.playOffset + (sharedAudioCtx.currentTime - track.playStartTime);
    } else {
      cur = track.playOffset;
    }

    const newTime = Math.max(0, Math.min(track.duration, cur + direction * delta));

    if (track.isPlaying) {
      stopPlayback(track);
      startPlayback(track, newTime);
    } else {
      track.playOffset = newTime;
      updatePlayhead(track);
    }
  }
});

// == Window Resize ============================================================
window.addEventListener('resize', () => {
  for (const track of tracks) {
    if (track.audioBuffer) {
      computeWaveformPeaks(track);
      drawTimeline(track);
    }
  }
});
</script>
</body>
</html>
